import type { User, CalculationResult } from '../db';

export interface CalculationAmounts {
    casino: number;
    slot: number;
    losing: number;
}

export interface BatchInput {
    performerId: number;
    amounts: CalculationAmounts;
}

/**
 * Calculates commissions for a batch of performance inputs.
 * For each performer, it calculates their direct commission and then
 * walks up the hierarchy to calculate differential commissions for uplines.
 */
export async function calculateBatchCommission(
    inputs: BatchInput[],
    allUsers: User[]  // Now passed as parameter instead of fetched from DB
): Promise<CalculationResult[]> {
    const resultsMap = new Map<string, CalculationResult>();

    // 1. Create a map for easy input lookup
    const inputMap = new Map<number, CalculationAmounts>();
    inputs.forEach(i => inputMap.set(i.performerId, i.amounts));

    // 2. Calculate Net Rolling for each user
    // Net = UserInput - Sum(DirectChildrenInputs)
    const netInputs: BatchInput[] = [];

    // We only process users who are in the input list (or have inputs)
    // But technically we should check all users who might have inputs? 
    // The inputs array contains everyone with an entry.
    for (const input of inputs) {
        const user = allUsers.find(u => u.id === input.performerId);
        if (!user) continue;

        // Find direct children
        const children = allUsers.filter(u => u.parentId === user.id);

        // Sum children's inputs
        const childrenSum = { casino: 0, slot: 0, losing: 0 };
        children.forEach(child => {
            const childInput = inputMap.get(child.id!) || { casino: 0, slot: 0, losing: 0 };
            childrenSum.casino += childInput.casino;
            childrenSum.slot += childInput.slot;
            childrenSum.losing += childInput.losing;
        });

        // Calculate Net
        const netAmounts = {
            casino: input.amounts.casino - childrenSum.casino,
            slot: input.amounts.slot - childrenSum.slot,
            losing: input.amounts.losing - childrenSum.losing
        };

        // If net is negative, it's a data error (Total < Parts), but we'll process it 
        // as is for now or clamp to 0? User said it "is a problem".
        // For consistent accounting, we should probably allow negative to show the discrepancy,
        // or just process it. If we process negative commission, it subtracts.
        // Let's stick to the raw math.

        if (netAmounts.casino !== 0 || netAmounts.slot !== 0 || netAmounts.losing !== 0) {
            netInputs.push({
                performerId: user.id!,
                amounts: netAmounts
            });
        }
    }

    const addToResult = (userId: number, userName: string, amount: number, role: 'self' | 'upper', source: 'casino' | 'slot' | 'losing', breakdown: string) => {
        const key = `${userId}-${source}`;
        const existing = resultsMap.get(key);
        if (existing) {
            existing.amount += amount;
            existing.breakdown = (existing.breakdown || '') + '\n' + breakdown;
        } else {
            resultsMap.set(key, {
                userId,
                userName,
                amount,
                role,
                source,
                breakdown
            });
        }
    };

    // 3. Process Commission based on NET inputs
    for (const input of netInputs) {
        // Skip if all zero (optimization)
        if (input.amounts.casino === 0 && input.amounts.slot === 0 && input.amounts.losing === 0) continue;

        const performer = allUsers.find((u: User) => u.id === input.performerId);
        if (!performer) continue;



        // Calculate Expenses (Commissions generated by this rolling) to deduct from Losing
        // Use PERFORMER's own rates for accurate per-member calculation
        const casinoExpense = input.amounts.casino * (Number(performer.casinoRate) / 100);
        const slotExpense = input.amounts.slot * (Number(performer.slotRate) / 100);

        // Calculate Adjusted Losing Base
        // Losing Commission Base = Losing Amount - (Casino Commission + Slot Commission)
        const adjustedLosingAmount = input.amounts.losing - (casinoExpense + slotExpense);

        (['casino', 'slot', 'losing'] as const).forEach(type => {
            let amount = 0;
            if (type === 'casino') amount = input.amounts.casino;
            else if (type === 'slot') amount = input.amounts.slot;
            else if (type === 'losing') amount = adjustedLosingAmount; // Use adjusted base

            // If amount is 0 (or negative?), no commission generated? 
            // If adjusted losing is negative (Won more in comms than lost), commission should probably be 0 or negative.
            // Let's allow negative for accuracy if that's the math, filtering is done later.
            if (amount === 0) return;

            let rateKey: keyof User;
            if (type === 'casino') rateKey = 'casinoRate';
            else if (type === 'slot') rateKey = 'slotRate';
            else rateKey = 'losingRate';

            // 1. Performer Commission (on their NET rolling/losing)
            const performerRate = Number(performer[rateKey]);
            const performerComm = amount * (performerRate / 100);

            // Build breakdown string for self commission
            let selfBreakdown = '';
            if (type === 'losing') {
                selfBreakdown = `[${performer.name} 본인] Losing 베이스 = ${input.amounts.losing.toLocaleString()} - (Casino비용 ${casinoExpense.toLocaleString()} + Slot비용 ${slotExpense.toLocaleString()}) = ${amount.toLocaleString()}
→ ${amount.toLocaleString()} × ${performerRate}% = ${performerComm.toLocaleString()}`;
            } else {
                selfBreakdown = `[${performer.name} 본인] NET ${type} = ${amount.toLocaleString()} × ${performerRate}% = ${performerComm.toLocaleString()}`;
            }
            addToResult(performer.id!, performer.name, performerComm, 'self', type, selfBreakdown);

            // 2. Upline Commission (Differential)
            let currentChildRate = performerRate;
            let currentParentId = performer.parentId;

            while (currentParentId) {
                const parent = allUsers.find(u => u.id === currentParentId);
                if (!parent) break;

                const parentRate = Number(parent[rateKey]);
                // Round difference to avoid floating point errors
                const rawDiff = parentRate - currentChildRate;
                const diffRate = Math.round(rawDiff * 10000) / 10000;

                // Only give commission if parent rate is strictly higher
                if (diffRate > 0) {
                    const parentComm = amount * (diffRate / 100);
                    const upperBreakdown = `[${parent.name} 차등] ${performer.name}의 NET ${type} ${amount.toLocaleString()} × (${parentRate}% - ${currentChildRate}%) = ${amount.toLocaleString()} × ${diffRate}% = ${parentComm.toLocaleString()}`;
                    addToResult(parent.id!, parent.name, parentComm, 'upper', type, upperBreakdown);
                    currentChildRate = parentRate;
                } else {
                    // Even if no comm, update rate if parent is higher (to block higher uplines)
                    if (parentRate > currentChildRate) {
                        currentChildRate = parentRate;
                    }
                }

                currentParentId = parent.parentId;
            }
        });
    }

    // Convert map to array and sort by amount desc
    return Array.from(resultsMap.values()).sort((a, b) => b.amount - a.amount);
}
